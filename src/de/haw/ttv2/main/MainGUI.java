package de.haw.ttv2.main;

import java.net.MalformedURLException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.ContentDisplay;
import javafx.scene.control.Label;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.layout.Border;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.BorderStroke;
import javafx.scene.layout.BorderStrokeStyle;
import javafx.scene.layout.CornerRadii;
import javafx.scene.layout.TilePane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;
import javafx.util.Duration;
import de.haw.ttv2.main.BroadcastLog.BroadcastMsg;
import de.haw.ttv2.main.network.NetworkInterfaceInfo;
import de.uniba.wiai.lspi.chord.data.ID;
import de.uniba.wiai.lspi.chord.data.URL;
import de.uniba.wiai.lspi.chord.service.PropertiesLoader;
import de.uniba.wiai.lspi.chord.service.ServiceException;
import de.uniba.wiai.lspi.chord.service.impl.ChordImpl;

/**
 * Main-Class, contains all relevant Method for creating the GUI and the Chord
 * and also for joining an existing Chord or create a Server
 * 
 * @author Johann Bronsch
 * @author Sascha Waltz
 */
public class MainGUI extends Application {

	private static final String PROTOCOL = URL.KNOWN_PROTOCOLS.get(URL.SOCKET_PROTOCOL);

	private static final double WINDOW_WIDTH = 1200;
	private static final double WINDOW_HEIGHT = 600;
	private static final double RIGHT_WINDOW_SIZE = 200;

	private static final double BUTTON_WIDTH = 190;
	private static final double BUTTON_HEIGHT = 33;

	private static final double FRAME_DURATION = 25;

	private ChordImpl chordImpl;
	private GameState gameState;

	private ComboBox<String> cb;
	private String ipTextField;
	private String portTextField;

	private int playerCount = 0;

	private boolean gameStarted = false;

	private Circle statusCircle;

	private VBox vboxMenu = new VBox(10);

	public TextArea outputTextArea;

	private Timeline animation;

	private Button startButton;

	private TilePane tilePane;

	private PlayerStatusEnum lastPlayerState;

	private Integer lastKnownTransactionID = -1;

	private TextField tf_transactionID;

	/**
	 * Initialize the GUI with all his elements, also creating a Thread for CoAP-Messages
	 * 
	 * @param primaryStage = Generated by JavaFX
	 */
	private void init(Stage primaryStage) {
		lastPlayerState = PlayerStatusEnum.GREEN;
		Thread t = new Thread(new CoapThread(PlayerStatusEnum.GREEN));
		t.start();
		Group root = new Group();
		primaryStage.setResizable(false);
		primaryStage.setScene(new Scene(root, WINDOW_WIDTH, WINDOW_HEIGHT));
		BorderPane borderPane = new BorderPane();
		// Menu
		VBox rightBox = new VBox();
		rightBox.setMinWidth(RIGHT_WINDOW_SIZE);
		cb = createNIIAComboBox();
		vboxMenu.getChildren().add(cb);
		vboxMenu.getChildren().addAll(createTextFields());
		vboxMenu.getChildren().addAll(createServerAndClientButtons());
		startButton.setDisable(true);
		vboxMenu.getChildren().add(createStatusCircle());
		vboxMenu.setAlignment(Pos.CENTER);
		rightBox.getChildren().add(vboxMenu);
		borderPane.setRight(rightBox);
		// Infobox
		VBox centerBox = new VBox();
		TabPane tabPane = new TabPane();
		tabPane.setPrefSize((WINDOW_WIDTH - RIGHT_WINDOW_SIZE) - 5, WINDOW_HEIGHT);
		tabPane.setSide(Side.TOP);
		tabPane.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE);
		Tab tab1 = new Tab();
		tab1.setText("Text Output");
		Tab tab2 = new Tab();
		tab2.setText("Visual Output");
		outputTextArea = new TextArea();
		outputTextArea.setMinSize((WINDOW_WIDTH - RIGHT_WINDOW_SIZE) - 10, WINDOW_HEIGHT - 30);
		outputTextArea.setMaxSize((WINDOW_WIDTH - RIGHT_WINDOW_SIZE) - 10, WINDOW_HEIGHT - 30);
		VBox vboxCenter = new VBox();
		vboxCenter.getChildren().add(outputTextArea);
		vboxCenter.setAlignment(Pos.CENTER);
		centerBox.getChildren().add(vboxCenter);
		centerBox.setMinWidth(WINDOW_WIDTH - RIGHT_WINDOW_SIZE);
		tab1.setContent(centerBox);
		tilePane = new TilePane();
		tab2.setContent(tilePane);
		tabPane.getTabs().addAll(tab1, tab2);
		borderPane.setCenter(tabPane);
		root.getChildren().add(borderPane);
	}

	/**
	 * Create a visualization for one Player (Constructor-Method)
	 * 
	 * @param player = Main ID of a Player
	 * @param progress = (SHIP_COUNT - Remaining_Ships) * (SHIP_COUNT / 100)
	 * @param color = GREEN, BLUE, VIOLETT, RED
	 * @param transactionID = Round
	 * @return
	 */
	private BorderPane createItem(ID player, double progress, Color color, int transactionID) {
		BorderPane borderPane = new BorderPane();
		VBox rightBox = new VBox(5);
		rightBox.setMinWidth(120);
		rightBox.setMinHeight(130);
		rightBox.setMaxWidth(120);
		rightBox.setMaxHeight(130);
		rightBox.getChildren().add(new Circle(50, color));
		rightBox.setAlignment(Pos.CENTER);
		borderPane.setRight(rightBox);
		VBox centerBox = new VBox(5);
		centerBox.setMinWidth(370);
		centerBox.setMinHeight(130);
		centerBox.setMaxWidth(370);
		centerBox.setMaxHeight(130);
		centerBox.setAlignment(Pos.CENTER);
		TextField idText = new TextField(player.toString());
		idText.setMinSize(360, 20);
		idText.setAlignment(Pos.CENTER);
		idText.setDisable(true);
		Label idLabel = new Label("Player ID", idText);
		idLabel.setContentDisplay(ContentDisplay.BOTTOM);
		centerBox.getChildren().add(idLabel);
		ProgressBar playerProgress = new ProgressBar();
		playerProgress.setProgress(progress);
		playerProgress.setMinWidth(360);
		Label prLabel = new Label("Player hitted ships", playerProgress);
		prLabel.setContentDisplay(ContentDisplay.BOTTOM);
		centerBox.getChildren().add(prLabel);
		TextField taText = new TextField(String.valueOf(transactionID));
		taText.setMinSize(40, 20);
		taText.setMaxSize(40, 20);
		taText.setDisable(true);
		Label taLabel = new Label("TransactionID of last Hit: ", taText);
		taLabel.setContentDisplay(ContentDisplay.RIGHT);
		centerBox.getChildren().add(taLabel);
		borderPane.setCenter(centerBox);
		borderPane.setBorder(new Border(new BorderStroke(Color.DARKGRAY, BorderStrokeStyle.SOLID, new CornerRadii(15),
				BorderStroke.THIN)));
		return borderPane;
	}

	/**
	 * Creates JavaFX - Circle with green color and set the global variable for statusCircle
	 * 
	 * @return
	 */
	private Circle createStatusCircle() {
		statusCircle = new Circle(70, Color.GREEN);
		return statusCircle;
	}

	/**
	 * Create an JavaFX-Node List with all necessary buttons and also the actions of these buttons.
	 * 
	 * @return
	 */
	private List<Node> createServerAndClientButtons() {
		startButton = createButton("Start Game", BUTTON_WIDTH, BUTTON_HEIGHT, new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent e) {
				gameState.startGame();
				gameStarted = true;
			}
		});
		return Arrays.asList(
				createButton("Create Server", BUTTON_WIDTH, BUTTON_HEIGHT, new EventHandler<ActionEvent>() {
					// Create Server with own IP and Port
					@Override
					public void handle(ActionEvent e) {
						if (Integer.valueOf(tf_transactionID.getText()) == -666) {
							gameState.setCheatMode(true);
							GUIMessageQueue.getInstance().addMessage("CheatMode activated!!!\n");
						}
						URL localURL = null;
						try {
							localURL = new URL(PROTOCOL + "://" + cb.getValue() + ":" + portTextField + "/");
						} catch (MalformedURLException error) {
							throw new RuntimeException(error);
						}

						try {
							if (cb.getValue() != null) {
								if (!cb.getValue().isEmpty()) {
									chordImpl.create(localURL);
									GUIMessageQueue.getInstance().addMessage("Chord listens on: " + localURL + "\n");
									Thread thread = new Thread(new JoiningThread(chordImpl));
									thread.start();
								}
							}
						} catch (ServiceException error) {
							throw new RuntimeException("Could not create DHT!", error);
						}
					}
				}), createButton("Join a Server", BUTTON_WIDTH, BUTTON_HEIGHT, new EventHandler<ActionEvent>() {
					//Joins an existing Server with given IP and Port
					@Override
					public void handle(ActionEvent e) {
						if (Integer.valueOf(tf_transactionID.getText()) == -666) {
							gameState.setCheatMode(true);
							GUIMessageQueue.getInstance().addMessage("CheatMode activated!!!\n");
						}
						URL localURL = null;
						try {
							localURL = new URL(PROTOCOL + "://" + cb.getValue() + ":" + portTextField + "/");
						} catch (MalformedURLException error) {
							throw new RuntimeException(error);
						}

						URL serverURL = null;
						try {
							serverURL = new URL(PROTOCOL + "://" + ipTextField + ":" + portTextField + "/");
						} catch (MalformedURLException error) {
							throw new RuntimeException(error);
						}
						try {
							if (cb.getValue() != null && ipTextField != null) {
								if (!cb.getValue().isEmpty() && !ipTextField.isEmpty()) {
									chordImpl.join(localURL, serverURL);
									GUIMessageQueue.getInstance().addMessage("Joined Server: " + serverURL + "\n");
								}
							}
						} catch (ServiceException error) {
							throw new RuntimeException("Could not join DHT!", error);
						}
					}
				}),
				createButton("Disconnect from Server", BUTTON_WIDTH, BUTTON_HEIGHT, new EventHandler<ActionEvent>() {
					@Override
					// Disconnect from Server
					public void handle(ActionEvent e) {
						chordImpl.leave();
						GUIMessageQueue.getInstance().addMessage("Disconnected\n");
					}
				}), createButton("Close Application", BUTTON_WIDTH, BUTTON_HEIGHT, new EventHandler<ActionEvent>() {
					@Override
					// Close Application
					public void handle(ActionEvent e) {
						chordImpl.leave();
						System.exit(0);
						System.out.println("Application Closed");
					}
				}), createButton("Create Gamefield", BUTTON_WIDTH, BUTTON_HEIGHT, new EventHandler<ActionEvent>() {
					@Override
					//Create Gamefield
					//is useful for debugging but not necessary
					public void handle(ActionEvent e) {
						gameState.createGamefield();
					}
				}), startButton);
	}

	/** 
	 * JavaFX Start-Method, initialize Chord and GUI. Also starts GUI update function
	 */
	@Override
	public void start(Stage primaryStage) throws Exception {
		initChord();
		init(primaryStage);
		animation = new Timeline();
		animation.getKeyFrames().add(new KeyFrame(Duration.millis(FRAME_DURATION), new EventHandler<ActionEvent>() {

			@Override
			//Update all GUI elements, like Output Text Area or the visualization of each player
			public void handle(ActionEvent arg0) {
				final BroadcastLog bcLog = BroadcastLog.getInstance();
				String message = GUIMessageQueue.getInstance().getFirstMessage();
				if (message != null)
					outputTextArea.appendText(message + "\n");
				if (bcLog.getMessageWithDiffrentSrc() != null)
					if (bcLog.getMessageWithDiffrentSrc().length() != 0)
						System.out.println(bcLog.getMessageWithDiffrentSrc());
				if (gameState.getOwnPlayer() != null) {
					vboxMenu.getChildren().remove(statusCircle);
					statusCircle = new Circle(70, gameState.getOwnPlayer().getPlayerStatus().getColor());
					if (lastPlayerState.compareTo(gameState.getOwnPlayer().getPlayerStatus()) != 0) {
						Thread t = new Thread(new CoapThread(gameState.getOwnPlayer().getPlayerStatus()));
						t.start();
						lastPlayerState = gameState.getOwnPlayer().getPlayerStatus();
					}
					vboxMenu.getChildren().add(statusCircle);
				}
				try {
					final int newPlayerCount = new HashSet<>(chordImpl.getFingerTable()).size();
					if (newPlayerCount > playerCount && !gameStarted) {
						playerCount = newPlayerCount;
						gameState.createGamefield();
						if (chordImpl.getPredecessorID().compareTo(chordImpl.getID()) > 0) {
							startButton.setDisable(false);
						}
						if (!startButton.isDisabled() && chordImpl.getPredecessorID().compareTo(chordImpl.getID()) <= 0)
							startButton.setDisable(true);
					}
				} catch (NullPointerException e) {
					// if catched, then game not started!
				}
				Map<ID, List<BroadcastMsg>> bclHittingMap = bcLog.getHittingMap();
				Map<ID, List<BroadcastMsg>> bclMap = bcLog.getLogMap();
				tilePane.getChildren().clear();
				if (gameState.getOwnPlayer() != null)
					tilePane.getChildren().add(
							createItem(chordImpl.getID(), ((double) GameState.SHIP_COUNT - (double) gameState
									.getOwnPlayer().getRemainingShips()) * ((double) GameState.SHIP_COUNT / 100d),
									gameState.getOwnPlayer().getPlayerStatus().getColor(), gameState.getOwnPlayer()
											.getTransactionIdOfHit()));
				for (ID id : bclMap.keySet()) {
					if (bclHittingMap.get(id) != null) {
						tilePane.getChildren()
								.add(createItem(
										id,
										(double) bclHittingMap.get(id).size() * ((double) GameState.SHIP_COUNT / 100d),
										getPlayerStatus(GameState.SHIP_COUNT - bclHittingMap.get(id).size()).getColor(),
										bclHittingMap.get(id).get(bclHittingMap.get(id).size() - 1).getTransaction()));
					} else {
						tilePane.getChildren().add(createItem(id, 0, PlayerStatusEnum.GREEN.getColor(), -1));
					}
				}
				BroadcastMsg lastBroadcast = bcLog.getLastBroadcast();
				if (lastBroadcast != null)
					if (lastKnownTransactionID != lastBroadcast.getTransaction()) {
						lastKnownTransactionID = lastBroadcast.getTransaction();
						tf_transactionID.setText(String.valueOf(lastKnownTransactionID));
					}
			}
		}));
		animation.setCycleCount(Animation.INDEFINITE);
		animation.play();
		primaryStage.show();
	}

	/**
	 * Returns the Status Enumeration depending on given remaining ships 
	 * 
	 * @param remainingShips
	 * @return
	 */
	private PlayerStatusEnum getPlayerStatus(int remainingShips) {
		if (GameState.SHIP_COUNT == remainingShips) {
			return PlayerStatusEnum.GREEN;
		} else if (shipCountBetween(GameState.SHIP_COUNT / 2, GameState.SHIP_COUNT, remainingShips)) {
			return PlayerStatusEnum.BLUE;
		} else if (shipCountBetween(1, GameState.SHIP_COUNT / 2, remainingShips)) {
			return PlayerStatusEnum.VIOLET;
		} else
			return PlayerStatusEnum.RED;
	}

	/**
	 * Helper-Method for getPlayerStatus
	 * 
	 * @param a
	 * @param b
	 * @param remainingShips
	 * @return
	 */
	private boolean shipCountBetween(int a, int b, int remainingShips) {
		if (a <= remainingShips && b > remainingShips)
			return true;
		return false;
	}

	/**
	 * Initialization Method for Chord and GameState
	 */
	private void initChord() {
		PropertiesLoader.loadPropertyFile();
		chordImpl = new ChordImpl();
		gameState = new GameState(chordImpl);
		chordImpl.setCallback(gameState);
	}

	public static void main(String[] args) {
		launch(args);
	}

	/**
	 * Creates all necessary TextFields and also the Labels for GUI, CheatMode activation is hidden in the 
	 * TransactionID Textfield. If the number of TransactionID is -666 before joining or creating a server
	 * the CheatMode is activated.
	 * 
	 * @return
	 */
	private List<Label> createTextFields() {
		Label ipText = createTextField("Server IP, if Client!", "", new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				ipTextField = newValue;
			}
		});
		Label portText = createTextField("Input Port:", "8585", new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				portTextField = newValue;
			}
		});
		portTextField = "8585";
		TextField text = new TextField(String.valueOf(lastKnownTransactionID));
		text.setMinSize(190, 20);
		Label label = new Label("Last known TransactionID:", text);
		label.setContentDisplay(ContentDisplay.BOTTOM);
		tf_transactionID = text;
		return Arrays.asList(ipText, portText, label);
	}

	/**
	 * Constructor Method, creates JavaFX-Label and -TextField combination with given parameters
	 * 
	 * @param labelText
	 * @param stdText
	 * @param changeListener
	 * @return
	 */
	private Label createTextField(String labelText, String stdText, ChangeListener<String> changeListener) {
		TextField text = new TextField(stdText);
		text.setMinSize(190, 20);
		if (changeListener != null)
			text.textProperty().addListener(changeListener);
		Label label = new Label(labelText, text);
		label.setContentDisplay(ContentDisplay.BOTTOM);
		return label;
	}

	/**
	 * Create a JavaFX-ComboBox with all own IPv4 IPs for GUI 
	 * 
	 * @return
	 */
	private ComboBox<String> createNIIAComboBox() {
		ComboBox<String> cb = new ComboBox<String>();
		cb.setId("cb_NI");
		cb.setPromptText("Choose own IP-Address!");
		cb.setMinSize(190, 20);
		cb.setItems(FXCollections.observableArrayList(NetworkInterfaceInfo.getNIIA()));
		return cb;
	}

	/**
	 * Constructor Method, creates Button with given parameters
	 * 
	 * @param text
	 * @param xSize
	 * @param ySize
	 * @param event
	 * @return
	 */
	private Button createButton(String text, double xSize, double ySize, EventHandler<ActionEvent> event) {
		Button button = new Button(text);
		button.setMinSize(xSize, ySize);
		button.setOnAction(event);
		return button;
	}
}
